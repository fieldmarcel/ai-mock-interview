  import {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } from "@google/generative-ai";

  const apiKey = process.env.GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "text/plain",
  };
  
  async function run() {
    const chatSession = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate a set of 10 interview questions along with their answers for the role of Full Stack Developer. The job description includes proficiency in ReactJS, NextJS, NodeJS, and ExpressJS. The candidate is expected to have 6 years of experience.\n\nThe interview questions should cover the following aspects:\n\nTechnical Skills: In-depth knowledge of the specified technologies.\nProblem-Solving Ability: Real-world scenarios and challenges.\nSystem Design: Building scalable and efficient applications.\nBest Practices: Code quality, optimization, and testing.\nSoft Skills: Communication, teamwork, and project management.\nProvide the questions and answers in JSON format with the following structure:\n\nquestion: The interview question.\nanswer: The recommended answer, including explanations and key concepts.\ndifficulty: Level of difficulty (easy, medium, hard).\ncategory: Technology, Problem-Solving, System Design, Best Practices, Soft Skills.\nAdditionally, ask the user for more specific details before generating the questions:\n\nCompany Name: To tailor questions to the companyâ€™s domain or project type.\nProject Type: Web application, API development, microservices, etc.\nTechnical Focus: Frontend-heavy, backend-heavy, or full stack.\nIndustry: E-commerce, finance, healthcare, etc.\nTeam Size: Working individually or within a team.\nSoft Skills Emphasis: Leadership, collaboration, or client communication."},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "Okay, I'm ready to generate the interview questions. First, I need some more details from you. Please provide the following information:\n\n*   **Company Name:**\n*   **Project Type:**\n*   **Technical Focus:**\n*   **Industry:**\n*   **Team Size:**\n*   **Soft Skills Emphasis:**\n\nOnce I have this information, I will generate the 10 interview questions in JSON format as you requested.\n"},
          ],
        },
        {
          role: "user",
          parts: [
            {text: "Company Name: microsoft, technixal focus- frontend  just only remove other 4  and then provide ques and ans\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "Okay, I will tailor the questions to Microsoft, focusing heavily on frontend and specifically removing dependency on project type, industry, team size, and soft skills emphasis details. Here are the 10 interview questions in JSON format:\n\n```json\n[\n  {\n    \"question\": \"Explain the virtual DOM in ReactJS and how it optimizes updates.  How does React handle reconciliation, and what are the key considerations for minimizing unnecessary re-renders?\",\n    \"answer\": \"The virtual DOM is a lightweight representation of the actual DOM.  React uses it to track changes and then efficiently updates only the parts of the real DOM that have changed. Reconciliation is the process React uses to compare the virtual DOM with the previous state and determine the minimal set of changes to apply to the actual DOM.  Key considerations for minimizing re-renders include using `React.memo`, `useMemo`, and `useCallback` to prevent unnecessary re-renders of components that haven't received new props.  Also, immutability is crucial for efficient change detection.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Technology\"\n  },\n  {\n    \"question\": \"Describe your experience with Next.js's data fetching methods like `getStaticProps`, `getServerSideProps`, and `getInitialProps`. When would you use each, and what are the trade-offs?\",\n    \"answer\": \"`getStaticProps` is used for pre-rendering pages with data fetched at build time, ideal for content that doesn't change frequently (e.g., blog posts). `getServerSideProps` fetches data on each request, suitable for dynamic content that needs to be up-to-date.  `getInitialProps` is an older method and generally less preferred now.  Trade-offs include build time vs. request time data fetching, SEO considerations, and the need for revalidation strategies for static data. `getStaticProps` improve performance by build time. `getServerSideProps` render on each request. For components, use SWR or React Query to fetch data.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Technology\"\n  },\n  {\n    \"question\": \"You need to build a complex form with multiple fields, validations, and dependencies between fields in React. Describe your approach to managing the form state and handling the form logic efficiently. What libraries or techniques would you consider?\",\n    \"answer\": \"I would consider using a library like Formik or React Hook Form to manage the form state and validation. These libraries provide a structured way to handle form submissions, validation, and error handling.  Alternatively, I could use React's built-in `useState` and `useReducer` hooks for smaller, less complex forms. For complex dependencies, I would use conditional logic within the validation schema or create custom validation functions. Debouncing and throttling can improve performance with complex forms by preventing excessive validations on rapid inputs.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Problem-Solving\"\n  },\n  {\n    \"question\": \"Explain the concept of Server-Side Rendering (SSR) and Static Site Generation (SSG). What are the advantages and disadvantages of each approach, particularly in the context of a large-scale application?\",\n    \"answer\": \"SSR renders pages on the server before sending them to the client, improving SEO and perceived performance by reducing initial load time.  SSG generates static HTML files at build time, offering excellent performance and scalability but requiring a rebuild for content updates. SSR advantages include better SEO and dynamic content handling. Disadvantages: higher server load. SSG advantages: Great for static content and fast. Disadvantages: requires rebuild. In a large-scale application, a hybrid approach might be optimal, using SSG for static content and SSR for dynamic pages.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"System Design\"\n  },\n  {\n    \"question\": \"Describe your experience with testing React components. What types of tests (unit, integration, end-to-end) have you written, and what tools do you prefer (e.g., Jest, React Testing Library, Cypress)? Give an example of testing a specific component for different scenarios.\",\n    \"answer\": \"I have experience writing unit tests, integration tests, and end-to-end tests for React components. I prefer using Jest and React Testing Library for unit and integration tests, as they encourage testing component behavior rather than implementation details. I would use Cypress for end-to-end tests to ensure the application works correctly from a user's perspective.  For example, a form component could have unit tests to validate input fields, integration tests to ensure the form submits correctly, and end-to-end tests to verify the entire form flow from user input to data persistence.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Best Practices\"\n  },\n    {\n    \"question\": \"Explain different optimization techniques to improve the rendering performance of a React application. Consider scenarios involving large lists and frequent updates.\",\n    \"answer\": \"Several optimization techniques can improve React rendering performance. These include: 1. **Memoization (React.memo, useMemo, useCallback):** Prevents unnecessary re-renders of components and expensive calculations. 2. **Virtualization (react-window, react-virtualized):**  Efficiently renders large lists by only rendering the visible items. 3. **Code Splitting (React.lazy, import()):** Reduces initial bundle size by loading code only when needed. 4. **Debouncing and Throttling:** Limits the frequency of updates in response to user input or events. 5. **Immutability:**  Ensures efficient change detection by creating new objects instead of modifying existing ones. 6. **Profiling:**  Using React Profiler to identify performance bottlenecks and optimize accordingly.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Best Practices\"\n  },\n  {\n    \"question\": \"Describe a time you had to debug a complex performance issue in a React application. What tools and techniques did you use to identify and resolve the problem?\",\n    \"answer\": \"I once faced a performance issue where a React application was experiencing slow rendering due to frequent re-renders of a deeply nested component. I used the React Profiler to identify the component causing the bottleneck.  Then, I analyzed the component's props and state updates, discovering that a parent component was unnecessarily triggering re-renders. I used `React.memo` to prevent the component from re-rendering when its props hadn't changed, significantly improving performance.\",\n    \"difficulty\": \"hard\",\n    \"category\": \"Problem-Solving\"\n  },\n  {\n    \"question\": \"How would you approach designing a scalable component library using React and Next.js that can be easily maintained and extended by other developers?\",\n    \"answer\": \"I would start by defining a clear set of design principles and guidelines. The component library should be built using a modular architecture with well-defined interfaces and reusable components. Storybook would be used for documentation and showcasing the components. I would follow a consistent coding style and use TypeScript for type safety. Version control and continuous integration would be essential for maintaining the library and ensuring code quality. Publish components as an NPM package for easy integration into other projects.\",\n    \"difficulty\": \"hard\",\n    \"category\": \"System Design\"\n  },\n  {\n    \"question\": \"Explain different architectural patterns commonly used in React applications (e.g., MVC, Flux, Redux, Context API). What are the advantages and disadvantages of each, and when would you choose one over the others?\",\n    \"answer\": \"MVC separates data (model), UI (view), and logic (controller), but can become complex in React. Flux is a unidirectional data flow pattern, often used with Redux. Redux provides a centralized state management solution, suitable for complex applications with shared state. The Context API is a simpler alternative for managing state at a component tree level.  I would choose Redux for large-scale applications with complex state management needs, the Context API for simpler applications, and avoid MVC in React.\",\n    \"difficulty\": \"medium\",\n    \"category\": \"Technology\"\n  },\n  {\n    \"question\": \"Describe how you would handle authentication and authorization in a Next.js application. Consider different authentication methods (e.g., JWT, OAuth) and strategies for protecting routes and API endpoints.\",\n    \"answer\": \"For authentication, I would use JWT (JSON Web Tokens) or OAuth. With JWT, the client receives a token after successful login, which is then sent with each request.  On the server-side (API routes), I would verify the token's authenticity before processing the request. For OAuth (e.g., using NextAuth.js), I would leverage providers like Google or GitHub for authentication.  Route protection in Next.js can be achieved using middleware to check for authentication and redirect unauthorized users to the login page. The token can be stored in HttpOnly cookies for security reasons.\",\n    \"difficulty\": \"hard\",\n    \"category\": \"System Design\"\n  }\n]\n```\n"},
          ],
        },
      ],
    });
  
    const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    console.log(result.response.text());
  }
  
  run();